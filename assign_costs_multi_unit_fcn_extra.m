%%% Determines additional costs due to multipliers lambda_P and lambda_H

function [decided_costs_extra] = assign_costs_multi_unit_fcn_extra(total_nodes, sol_select, time_from, n_tsteps, from_state_map, to_state_map, power_map, heat_map, power_demand, heat_demand, lambda)

Weight1 = 1;
Weight2 = 1;

av_P_demand = ( ...
  Weight1 * [zeros(total_nodes, 1); ...
  power_demand(time_from(total_nodes+1:end-total_nodes)); ... %first 46 and last 46 transitions have zero cost-> transitions from start and to end
  zeros(total_nodes, 1)] ...
  +Weight2 * [zeros(total_nodes, 1); ...
  power_demand((time_from(total_nodes+1:end-total_nodes), ...
  + n_tsteps(total_nodes+1:end-total_nodes))); ...
  zeros(total_nodes, 1)] ...
  ) / (Weight1 + Weight2);

av_H_demand = ( ...
  Weight1 * [zeros(total_nodes, 1); ...
  heat_demand(time_from(total_nodes+1:end-total_nodes)); ...
  zeros(total_nodes, 1)] ...
  +Weight2 * [zeros(total_nodes, 1); ...
  heat_demand((time_from(total_nodes+1:end-total_nodes), ...
  + n_tsteps(total_nodes+1:end-total_nodes))); ...
  zeros(total_nodes, 1)] ...
  ) / (Weight1 + Weight2);


av_lambda = ( ...
  Weight1 * [zeros(total_nodes, 2); ...
  lambda(time_from(total_nodes+1:end-total_nodes), :); ...
  zeros(total_nodes, 2)] ...
  +Weight2 * [zeros(total_nodes, 2); ...
  lambda((time_from(total_nodes+1:end-total_nodes), ...
  + n_tsteps(total_nodes+1:end-total_nodes)), :); ...
  zeros(total_nodes, 2)] ...
  ) / (Weight1 + Weight2);

% Compute average power and heat produced

av_H_produced = [zeros(numel(n_tsteps), 3), ...
  (Weight1 * [zeros(total_nodes, 1); ...
  heat_map(from_state_map(total_nodes+1:end-total_nodes)); ...
  zeros(total_nodes, 1)] ...
  +Weight2 * [zeros(total_nodes, 1); ...
  heat_map(to_state_map(total_nodes+1:end-total_nodes)); ...
  zeros(total_nodes, 1)] ...
  ) / (Weight1 + Weight2)];


av_P_produced = [zeros(numel(n_tsteps), 3), ...
  (Weight1 * [zeros(total_nodes, 1); ...
  power_map(from_state_map(total_nodes+1:end-total_nodes)); ...
  zeros(total_nodes, 1)] ...
  +Weight2 * [zeros(total_nodes, 1); ...
  power_map(to_state_map(total_nodes+1:end-total_nodes)); ...
  zeros(total_nodes, 1)] ...
  ) / (Weight1 + Weight2)];


decided_costs_extra_aux = -av_lambda(:, 1) .* av_P_produced - av_lambda(:, 2) .* av_H_produced;

decided_costs_extra = decided_costs_extra_aux(sub2ind(size(decided_costs_extra_aux), ...
  1:size(av_P_demand), ...
  sol_select.'))';